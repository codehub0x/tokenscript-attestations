/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 7.4.2, Date: 22-Jul-2020.
 */
package dk.alexandra.stormbird.cheque.asnobjects;

import com.objsys.asn1j.runtime.*;
import dk.alexandra.stormbird.cheque.asnobjects.Version;
import dk.alexandra.stormbird.cheque.asnobjects.CertificateSerialNumber;
import dk.alexandra.stormbird.cheque.asnobjects.AlgorithmIdentifier;
import dk.alexandra.stormbird.cheque.asnobjects.Name;
import dk.alexandra.stormbird.cheque.asnobjects.Validity;

public class SignedInfo extends Asn1Seq {
   private static final long serialVersionUID = 55;
   static {
      _setKey (_AttestationFrameworkRtkey._rtkey);
      Asn1Type._setLicLocation(_AttestationFrameworkRtkey._licLocation);
   }

   public String getAsn1TypeName()  {
      return "SignedInfo";
   }

   public Version version;
   public CertificateSerialNumber serialNumber;
   public AlgorithmIdentifier signature;
   public Name issuer;
   public Validity validity;
   public Name subject;
   public SubjectPublicKeyInfo subjectPublicKeyInfo;
   public _SeqOfSmartContract contract;  // optional
   public SignedInfo_attestsTo attestsTo;

   public SignedInfo () {
      super();
      init();
   }

   /**
    * This constructor sets all elements to references to the 
    * given objects
    */
   public SignedInfo (
      Version version_,
      CertificateSerialNumber serialNumber_,
      AlgorithmIdentifier signature_,
      Name issuer_,
      Validity validity_,
      Name subject_,
      SubjectPublicKeyInfo subjectPublicKeyInfo_,
      _SeqOfSmartContract contract_,
      SignedInfo_attestsTo attestsTo_
   ) {
      super();
      version = version_;
      serialNumber = serialNumber_;
      signature = signature_;
      issuer = issuer_;
      validity = validity_;
      subject = subject_;
      subjectPublicKeyInfo = subjectPublicKeyInfo_;
      contract = contract_;
      attestsTo = attestsTo_;
   }

   /**
    * This constructor is for required elements only.  It sets 
    * all elements to references to the given objects
    */
   public SignedInfo (
      Version version_,
      CertificateSerialNumber serialNumber_,
      AlgorithmIdentifier signature_,
      Name issuer_,
      Validity validity_,
      Name subject_,
      SubjectPublicKeyInfo subjectPublicKeyInfo_,
      SignedInfo_attestsTo attestsTo_
   ) {
      super();
      version = version_;
      serialNumber = serialNumber_;
      signature = signature_;
      issuer = issuer_;
      validity = validity_;
      subject = subject_;
      subjectPublicKeyInfo = subjectPublicKeyInfo_;
      attestsTo = attestsTo_;
   }

   /**
    * This constructor allows primitive data to be passed for all 
    * primitive elements.  It will create new object wrappers for 
    * the primitive data and set other elements to references to 
    * the given objects 
    */
   public SignedInfo (long version_,
      long serialNumber_,
      AlgorithmIdentifier signature_,
      Name issuer_,
      Validity validity_,
      Name subject_,
      SubjectPublicKeyInfo subjectPublicKeyInfo_,
      _SeqOfSmartContract contract_,
      SignedInfo_attestsTo attestsTo_
   ) {
      super();
      version = new Version (version_);
      serialNumber = new CertificateSerialNumber (serialNumber_);
      signature = signature_;
      issuer = issuer_;
      validity = validity_;
      subject = subject_;
      subjectPublicKeyInfo = subjectPublicKeyInfo_;
      contract = contract_;
      attestsTo = attestsTo_;
   }

   /**
    * This constructor is for required elements only.  It allows 
    * primitive data to be passed for all primitive elements.  
    * It will create new object wrappers for the primitive data 
    * and set other elements to references to the given objects. 
    */
   public SignedInfo (
      long version_,
      long serialNumber_,
      AlgorithmIdentifier signature_,
      Name issuer_,
      Validity validity_,
      Name subject_,
      SubjectPublicKeyInfo subjectPublicKeyInfo_,
      SignedInfo_attestsTo attestsTo_
   ) {
      super();
      version = new Version (version_);
      serialNumber = new CertificateSerialNumber (serialNumber_);
      signature = signature_;
      issuer = issuer_;
      validity = validity_;
      subject = subject_;
      subjectPublicKeyInfo = subjectPublicKeyInfo_;
      attestsTo = attestsTo_;
   }

   public void init () {
      version = null;
      serialNumber = null;
      signature = null;
      issuer = null;
      validity = null;
      subject = null;
      subjectPublicKeyInfo = null;
      contract = null;
      attestsTo = null;
   }

   public int getElementCount() { return 9; }


   public Object getElementValue(int index){
      switch(index)  {
         case 0: return version;
         case 1: return serialNumber;
         case 2: return signature;
         case 3: return issuer;
         case 4: return validity;
         case 5: return subject;
         case 6: return subjectPublicKeyInfo;
         case 7: return contract;
         case 8: return attestsTo;
         default: return null;
      }
   }


   public String getElementName(int index){
      switch(index)  {
         case 0: return "version";
         case 1: return "serialNumber";
         case 2: return "signature";
         case 3: return "issuer";
         case 4: return "validity";
         case 5: return "subject";
         case 6: return "subjectPublicKeyInfo";
         case 7: return "contract";
         case 8: return "attestsTo";
         default: return null;
      }
   }


   public void decode
      (Asn1BerDecodeBuffer buffer, boolean explicit, int implicitLength)
      throws Asn1Exception, java.io.IOException
   {
      int llen = (explicit) ?
         matchTag (buffer, Asn1Tag.SEQUENCE) : implicitLength;

      init ();

      // decode SEQUENCE

      Asn1BerDecodeContext _context =
         new Asn1BerDecodeContext (buffer, llen);

      IntHolder elemLen = new IntHolder();

      // decode version

      if (_context.matchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
         int loffset_ = buffer.getByteCount();
         buffer.getContext().eventDispatcher.startElement("version", -1);

         this.version = new Version();
         this.version.decode (buffer, true, elemLen.value);

         buffer.getContext().eventDispatcher.endElement("version", -1);

         int declen = buffer.getByteCount() - loffset_;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }
      else throw new Asn1MissingRequiredException (buffer, "version");

      // decode serialNumber

      if (_context.matchElemTag (Asn1Tag.UNIV, Asn1Tag.PRIM, 2, elemLen, false)) {
         buffer.getContext().eventDispatcher.startElement("serialNumber", -1);

         this.serialNumber = new CertificateSerialNumber();
         this.serialNumber.decode (buffer, true, elemLen.value);

         buffer.getContext().eventDispatcher.endElement("serialNumber", -1);
      }
      else throw new Asn1MissingRequiredException (buffer, "serialNumber");

      // decode signature

      if (_context.matchElemTag (Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
         buffer.getContext().eventDispatcher.startElement("signature", -1);

         this.signature = new AlgorithmIdentifier();
         this.signature.decode (buffer, true, elemLen.value);

         buffer.getContext().eventDispatcher.endElement("signature", -1);
      }
      else throw new Asn1MissingRequiredException (buffer, "signature");

      // decode issuer

      if (!_context.expired()) {
         Asn1Tag tag = buffer.peekTag ();
         if (tag.equals (Asn1Tag.UNIV, Asn1Tag.PRIM, 5) ||
             tag.equals (Asn1Tag.UNIV, Asn1Tag.CONS, 16))
         {
            buffer.getContext().eventDispatcher.startElement("issuer", -1);

            this.issuer = new Name();
            this.issuer.decode (buffer, true, elemLen.value);

            buffer.getContext().eventDispatcher.endElement("issuer", -1);
         }
         else throw new Asn1MissingRequiredException (buffer, "issuer");
      }
      else throw new Asn1MissingRequiredException (buffer, "issuer");

      // decode validity

      if (!_context.expired()) {
         Asn1Tag tag = buffer.peekTag ();
         if (tag.equals (Asn1Tag.UNIV, Asn1Tag.PRIM, 5) ||
             tag.equals (Asn1Tag.UNIV, Asn1Tag.CONS, 16))
         {
            buffer.getContext().eventDispatcher.startElement("validity", -1);

            this.validity = new Validity();
            this.validity.decode (buffer, true, elemLen.value);

            buffer.getContext().eventDispatcher.endElement("validity", -1);
         }
         else throw new Asn1MissingRequiredException (buffer, "validity");
      }
      else throw new Asn1MissingRequiredException (buffer, "validity");

      // decode subject

      if (!_context.expired()) {
         Asn1Tag tag = buffer.peekTag ();
         if (tag.equals (Asn1Tag.UNIV, Asn1Tag.PRIM, 5) ||
             tag.equals (Asn1Tag.UNIV, Asn1Tag.CONS, 16))
         {
            buffer.getContext().eventDispatcher.startElement("subject", -1);

            this.subject = new Name();
            this.subject.decode (buffer, true, elemLen.value);

            buffer.getContext().eventDispatcher.endElement("subject", -1);
         }
         else throw new Asn1MissingRequiredException (buffer, "subject");
      }
      else throw new Asn1MissingRequiredException (buffer, "subject");

      // decode subjectPublicKeyInfo

      if (!_context.expired()) {
         Asn1Tag tag = buffer.peekTag ();
         if (tag.equals (Asn1Tag.UNIV, Asn1Tag.PRIM, 5) ||
             tag.equals (Asn1Tag.UNIV, Asn1Tag.CONS, 16))
         {
            buffer.getContext().eventDispatcher.startElement("subjectPublicKeyInfo", -1);

            this.subjectPublicKeyInfo = new SubjectPublicKeyInfo();
            this.subjectPublicKeyInfo.decode (buffer, true, elemLen.value);

            buffer.getContext().eventDispatcher.endElement("subjectPublicKeyInfo", -1);
         }
         else throw new Asn1MissingRequiredException (buffer, "subjectPublicKeyInfo");
      }
      else throw new Asn1MissingRequiredException (buffer, "subjectPublicKeyInfo");

      // decode contract

      if (_context.matchElemTag (Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
         buffer.getContext().eventDispatcher.startElement("contract", -1);

         this.contract = new _SeqOfSmartContract();
         this.contract.decode (buffer, true, elemLen.value);

         buffer.getContext().eventDispatcher.endElement("contract", -1);
      }

      // decode attestsTo

      if (!_context.expired()) {
         Asn1Tag tag = buffer.peekTag ();
         if (tag.equals (Asn1Tag.CTXT, Asn1Tag.CONS, 3) ||
             tag.equals (Asn1Tag.CTXT, Asn1Tag.CONS, 4))
         {
            buffer.getContext().eventDispatcher.startElement("attestsTo", -1);

            this.attestsTo = new SignedInfo_attestsTo();
            this.attestsTo.decode (buffer, true, elemLen.value);

            buffer.getContext().eventDispatcher.endElement("attestsTo", -1);
         }
         else throw new Asn1MissingRequiredException (buffer, "attestsTo");
      }
      else throw new Asn1MissingRequiredException (buffer, "attestsTo");

      if (!_context.expired()) {
         Asn1Tag _tag = buffer.peekTag ();
         if (_tag.equals (Asn1Tag.CTXT, Asn1Tag.CONS, 0) ||
             _tag.equals (Asn1Tag.UNIV, Asn1Tag.PRIM, 2) ||
             _tag.equals (Asn1Tag.UNIV, Asn1Tag.CONS, 16))  {
            throw new Asn1SeqOrderException ();
         }
         else  {
            throw new Asn1UnexpectedElementException();
         }

      }
   }

   public int encode (Asn1BerEncodeBuffer buffer, boolean explicit)
      throws Asn1Exception
   {
      int _aal = 0, len;

      // encode attestsTo

      if (this.attestsTo != null) {
         buffer.getContext().eventDispatcher.startElement("attestsTo", -1);

         len = this.attestsTo.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("attestsTo", -1);
      }
      else throw new Asn1MissingRequiredException ("attestsTo");

      // encode contract

      if (this.contract != null) {
         buffer.getContext().eventDispatcher.startElement("contract", -1);

         len = this.contract.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("contract", -1);
      }

      // encode subjectPublicKeyInfo

      if (this.subjectPublicKeyInfo != null) {
         buffer.getContext().eventDispatcher.startElement("subjectPublicKeyInfo", -1);

         len = this.subjectPublicKeyInfo.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("subjectPublicKeyInfo", -1);
      }
      else throw new Asn1MissingRequiredException ("subjectPublicKeyInfo");

      // encode subject

      if (this.subject != null) {
         buffer.getContext().eventDispatcher.startElement("subject", -1);

         len = this.subject.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("subject", -1);
      }
      else throw new Asn1MissingRequiredException ("subject");

      // encode validity

      if (this.validity != null) {
         buffer.getContext().eventDispatcher.startElement("validity", -1);

         len = this.validity.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("validity", -1);
      }
      else throw new Asn1MissingRequiredException ("validity");

      // encode issuer

      if (this.issuer != null) {
         buffer.getContext().eventDispatcher.startElement("issuer", -1);

         len = this.issuer.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("issuer", -1);
      }
      else throw new Asn1MissingRequiredException ("issuer");

      // encode signature

      if (this.signature != null) {
         buffer.getContext().eventDispatcher.startElement("signature", -1);

         len = this.signature.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("signature", -1);
      }
      else throw new Asn1MissingRequiredException ("signature");

      // encode serialNumber

      if (this.serialNumber != null) {
         buffer.getContext().eventDispatcher.startElement("serialNumber", -1);

         len = this.serialNumber.encode (buffer, true);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("serialNumber", -1);
      }
      else throw new Asn1MissingRequiredException ("serialNumber");

      // encode version

      if (this.version != null) {
         buffer.getContext().eventDispatcher.startElement("version", -1);

         len = this.version.encode (buffer, true);
         len += buffer.encodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 0, len);
         _aal += len;

         buffer.getContext().eventDispatcher.endElement("version", -1);
      }
      else throw new Asn1MissingRequiredException ("version");

      if (explicit) {
         _aal += buffer.encodeTagAndLength (Asn1Tag.SEQUENCE, _aal);
      }

      return (_aal);
   }

   public void print (java.io.PrintWriter _out, String _varName, int _level)
   {
      indent (_out, _level);
      _out.println (_varName + " {");
      if (version != null) version.print (_out, "version", _level+1);
      if (serialNumber != null) serialNumber.print (_out, "serialNumber", _level+1);
      if (signature != null) signature.print (_out, "signature", _level+1);
      if (issuer != null) issuer.print (_out, "issuer", _level+1);
      if (validity != null) validity.print (_out, "validity", _level+1);
      if (subject != null) subject.print (_out, "subject", _level+1);
      if (subjectPublicKeyInfo != null) subjectPublicKeyInfo.print (_out, "subjectPublicKeyInfo", _level+1);
      if (contract != null) contract.print (_out, "contract", _level+1);
      if (attestsTo != null) attestsTo.print (_out, "attestsTo", _level+1);
      indent (_out, _level);
      _out.println ("}");
   }

}
